name: Simulated Customer Build Pipeline

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  # --- Validator Jobs ---
  codeowners_validator:
    name: CodeOwners Validator
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: CodeOwners Validation
        run: |
          echo "Simulating CodeOwners check..."
          echo "OK!"

  version_mods_validator:
    name: Version & Mods Validator
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Version & Mods Validation
        run: |
          echo "Simulating version & mods checks..."
          echo "Looks fine!"

  template_validator:
    name: Template Validator
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Template Validator Step
        run: |
          echo "Simulating template validation..."
          echo "All good!"

  # --- Final Build Job ---
  build:
    name: Build Artifacts
    needs: [codeowners_validator, version_mods_validator, template_validator]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false        # This ensures each artifact's build runs independently.
      matrix:
        artifact:
          - type: jar
            name: service1
            module: 'service1'
          - type: war
            name: war-service1
            module: 'war-service1'
          - type: frontend
            name: frontend-app
            dockerfile: './frontend/Dockerfile'
            context: './frontend'
    env:
      TIMESTAMP: ${{ github.run_id }}   # Using run_id as a pseudo-timestamp

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
      
      # Process JFrog URL for Docker builds only
      - name: Process Docker Registry URL
        if: matrix.artifact.type == 'frontend'
        run: |
          # Get JFrog URL from secrets
          JFROG_URL="${{ secrets.JFROG_URL }}"
          
          # Remove protocol prefix if present (http:// or https://)
          DOCKER_REPO=$(echo "$JFROG_URL" | sed -E 's#^https?://##')
          
          # Remove trailing slashes if present
          DOCKER_REPO=$(echo "$DOCKER_REPO" | sed 's#/$##')
          
          # Export for use in subsequent steps
          echo "DOCKER_REPO=$DOCKER_REPO" >> $GITHUB_ENV
          echo "Using Docker registry: $DOCKER_REPO"

      # Docker login for frontend builds
      - name: Login to JFrog Docker Registry
        if: matrix.artifact.type == 'frontend'
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REPO }}
          username: ${{ secrets.JFROG_USERNAME }}
          password: ${{ secrets.JFROG_PASSWORD }}

      # Frontend Docker build
      - name: Build Frontend Docker Image
        if: matrix.artifact.type == 'frontend'
        run: |
          echo "Building frontend Docker image: ${{ matrix.artifact.name }}..."
          
          # Build the Docker image
          docker build -t "${{ env.DOCKER_REPO }}/docker/${{ matrix.artifact.name }}:${TIMESTAMP}" \
            -f "${{ matrix.artifact.dockerfile }}" "${{ matrix.artifact.context }}"
          
          echo "Pushing to registry..."
          docker push "${{ env.DOCKER_REPO }}/docker/${{ matrix.artifact.name }}:${TIMESTAMP}"
          
          # Get image digest for later use
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' \
            "${{ env.DOCKER_REPO }}/docker/${{ matrix.artifact.name }}:${TIMESTAMP}" | cut -d':' -f2)
          echo "IMAGE_DIGEST=$IMAGE_DIGEST" >> $GITHUB_ENV

      # Check if JAR module exists before building
      - name: Verify JAR Module
        if: matrix.artifact.type == 'jar'
        id: check_jar_module
        run: |
          if [ -d "${{ matrix.artifact.module }}" ] && [ -f "${{ matrix.artifact.module }}/pom.xml" ]; then
            echo "module_exists=true" >> $GITHUB_OUTPUT
            echo "JAR module ${{ matrix.artifact.module }} exists and has pom.xml"
          else
            echo "module_exists=false" >> $GITHUB_OUTPUT
            echo "Warning: JAR module ${{ matrix.artifact.module }} not found or missing pom.xml"
            # Create directory and minimal pom.xml for testing purposes
            mkdir -p ${{ matrix.artifact.module }}/target
            echo "<project><modelVersion>4.0.0</modelVersion><groupId>com.example</groupId><artifactId>${{ matrix.artifact.module }}</artifactId><version>1.0.0</version></project>" > ${{ matrix.artifact.module }}/pom.xml
            echo "Created placeholder pom.xml for testing"
            echo "This is a test JAR" > ${{ matrix.artifact.module }}/target/test.jar
          fi

      # JAR build
      - name: Build and Push JAR Artifact
        if: matrix.artifact.type == 'jar' && steps.check_jar_module.outputs.module_exists == 'true'
        run: |
          echo "Building JAR for ${{ matrix.artifact.module }} module..."
          cd ${{ matrix.artifact.module }}
          mvn clean package -DskipTests
          cd ..
          
          # Check if any JAR files were generated
          if ls ${{ matrix.artifact.module }}/target/*.jar 1> /dev/null 2>&1; then
            JAR_FILE=$(ls ${{ matrix.artifact.module }}/target/*.jar | head -n 1)
            echo "Pushing JAR to JFROG Artifactory: $JAR_FILE"
            
            # Construct JFrog URL with protocol for curl
            JFROG_FULL_URL="${{ secrets.JFROG_URL }}"
            # Ensure it has a protocol prefix
            if [[ "$JFROG_FULL_URL" != http* ]]; then
              JFROG_FULL_URL="https://$JFROG_FULL_URL"
            fi
            
            curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_PASSWORD }}" \
              -T "$JAR_FILE" \
              "$JFROG_FULL_URL/my-jar-repo/${{ matrix.artifact.module }}/$(basename $JAR_FILE)"
          else
            echo "No JAR files found in ${{ matrix.artifact.module }}/target directory"
            exit 1
          fi

      # Check if WAR module exists before building
      - name: Verify WAR Module
        if: matrix.artifact.type == 'war'
        id: check_war_module
        run: |
          if [ -d "${{ matrix.artifact.module }}" ] && [ -f "${{ matrix.artifact.module }}/pom.xml" ]; then
            echo "module_exists=true" >> $GITHUB_OUTPUT
            echo "WAR module ${{ matrix.artifact.module }} exists and has pom.xml"
          else
            echo "module_exists=false" >> $GITHUB_OUTPUT
            echo "Warning: WAR module ${{ matrix.artifact.module }} not found or missing pom.xml"
            # Create directory and minimal pom.xml for testing purposes
            mkdir -p ${{ matrix.artifact.module }}/target
            echo "<project><modelVersion>4.0.0</modelVersion><groupId>com.example</groupId><artifactId>${{ matrix.artifact.module }}</artifactId><version>1.0.0</version><packaging>war</packaging></project>" > ${{ matrix.artifact.module }}/pom.xml
            echo "Created placeholder pom.xml for testing"
            echo "This is a test WAR" > ${{ matrix.artifact.module }}/target/test.war
          fi

      # WAR build
      - name: Build and Push WAR Artifact
        if: matrix.artifact.type == 'war' && steps.check_war_module.outputs.module_exists == 'true'
        run: |
          echo "Building WAR for ${{ matrix.artifact.module }} module..."
          cd ${{ matrix.artifact.module }}
          mvn clean package -DskipTests
          cd ..
          
          # Check if any WAR files were generated
          if ls ${{ matrix.artifact.module }}/target/*.war 1> /dev/null 2>&1; then
            WAR_FILE=$(ls ${{ matrix.artifact.module }}/target/*.war | head -n 1)
            echo "Pushing WAR to JFROG Artifactory: $WAR_FILE"
            
            # Construct JFrog URL with protocol for curl
            JFROG_FULL_URL="${{ secrets.JFROG_URL }}"
            # Ensure it has a protocol prefix
            if [[ "$JFROG_FULL_URL" != http* ]]; then
              JFROG_FULL_URL="https://$JFROG_FULL_URL"
            fi
            
            curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_PASSWORD }}" \
              -T "$WAR_FILE" \
              "$JFROG_FULL_URL/my-war-repo/${{ matrix.artifact.module }}/$(basename $WAR_FILE)"
          else
            echo "No WAR files found in ${{ matrix.artifact.module }}/target directory"
            exit 1
          fi
      
      # Generate test files if modules don't exist (for testing only)
      - name: Create Test Files For Missing Modules
        if: (matrix.artifact.type == 'jar' && steps.check_jar_module.outputs.module_exists == 'false') || (matrix.artifact.type == 'war' && steps.check_war_module.outputs.module_exists == 'false')
        run: |
          if [ "${{ matrix.artifact.type }}" = "jar" ]; then
            echo "Creating test JAR file"
            JAR_FILE="${{ matrix.artifact.module }}/target/test.jar"
            
            # Construct JFrog URL with protocol for curl
            JFROG_FULL_URL="${{ secrets.JFROG_URL }}"
            # Ensure it has a protocol prefix
            if [[ "$JFROG_FULL_URL" != http* ]]; then
              JFROG_FULL_URL="https://$JFROG_FULL_URL"
            fi
            
            curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_PASSWORD }}" \
              -T "$JAR_FILE" \
              "$JFROG_FULL_URL/my-jar-repo/${{ matrix.artifact.module }}/$(basename $JAR_FILE)"
          elif [ "${{ matrix.artifact.type }}" = "war" ]; then
            echo "Creating test WAR file"
            WAR_FILE="${{ matrix.artifact.module }}/target/test.war"
            
            # Construct JFrog URL with protocol for curl
            JFROG_FULL_URL="${{ secrets.JFROG_URL }}"
            # Ensure it has a protocol prefix
            if [[ "$JFROG_FULL_URL" != http* ]]; then
              JFROG_FULL_URL="https://$JFROG_FULL_URL"
            fi
            
            curl -u "${{ secrets.JFROG_USERNAME }}:${{ secrets.JFROG_PASSWORD }}" \
              -T "$WAR_FILE" \
              "$JFROG_FULL_URL/my-war-repo/${{ matrix.artifact.module }}/$(basename $WAR_FILE)"
          fi

      # Send notifications for all successful builds
      - name: Send Build Metadata to RabbitMQ
        if: success()
        env:
          RABBITMQ_URL: ${{ secrets.RABBITMQ_URL }}
          RABBITMQ_USER: ${{ secrets.RABBITMQ_USER }}
          RABBITMQ_PASS: ${{ secrets.RABBITMQ_PASS }}
        run: |
          if [ "${{ matrix.artifact.type }}" = "frontend" ]; then
            PAYLOAD=$(jq -n \
              --arg artifact "${{ matrix.artifact.name }}" \
              --arg tag "$TIMESTAMP" \
              --arg digest "sha256:${{ env.IMAGE_DIGEST }}" \
              '{artifact: $artifact, imageTag: $tag, digest: $digest}')
          elif [ "${{ matrix.artifact.type }}" = "jar" ]; then
            PAYLOAD=$(jq -n --arg artifact "${{ matrix.artifact.name }}" '{artifact: $artifact, type: "jar"}')
          elif [ "${{ matrix.artifact.type }}" = "war" ]; then
            PAYLOAD=$(jq -n --arg artifact "${{ matrix.artifact.name }}" '{artifact: $artifact, type: "war"}')
          fi

          echo "Sending build event to RabbitMQ for artifact: ${{ matrix.artifact.name }}"
          curl -u $RABBITMQ_USER:$RABBITMQ_PASS \
              -H "Content-Type: application/json" \
              -X POST "$RABBITMQ_URL/api/exchanges/%2F/build-events/publish" \
              --data-binary "$(jq -n --arg payload "$PAYLOAD" --arg routing_key "build.event" \
                '{vhost: "/", name: "build-events", routing_key: $routing_key, payload: $payload, payload_encoding: "string"}')"
